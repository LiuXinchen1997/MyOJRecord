### 1 dfs

深搜+剪枝的问题
本题本质就是在46的基础上继续剪枝。

如何防止重复：
可以考虑先将`nums`排序，再按全排列的方式dfs
注意：
```C++
if (i > 0 && nums[i] == nums[i-1] && !status[i-1]) { continue; }
```
`!status[i-1]`指的是上一个是撤销的状态，这很重要，如果没有这个的话，对于输入`[1,1,2]`，我们就得不到`[1,1,2]`的排列方式了。
